import frog from"/gfx/frog.mjs";const GFXMappings=(()=>{const e=WebGL2RenderingContext.prototype;return{shaderType(t){switch(t){case"vertex":return e.VERTEX_SHADER;case"fragment":return e.FRAGMENT_SHADER;default:throw new Error(`'${t}' is an invalid shader type`)}},numberType(t){switch(t){case"int8":return e.BYTE;case"uint8":return e.UNSIGNED_BYTE;case"int16":return e.SHORT;case"uint16":return e.UNSIGNED_SHORT;case"int32":return e.INT;case"uint32":return e.UNSIGNED_INT;case"float":return e.FLOAT;default:throw new Error(`'${t}' is invalid number type`)}},bufferUsage(t){if("string"==typeof t)switch(t){case"static-draw":return e.STATIC_DRAW;case"dynamic-draw":return e.DYNAMIC_DRAW;case"stream-draw":return e.STREAM_DRAW;case"static-read":return e.STATIC_READ;case"dynamic-read":return e.DYNAMIC_READ;case"stream-read":return e.STREAM_READ;case"static-copy":return e.STATIC_COPY;case"dynamic-copy":return e.DYNAMIC_COPY;case"stream-copy":return e.STREAM_COPY}else if("object"==typeof t&&null!=t){const r=[[{whoWrites:"CPU",whoReads:"GPU",writeRate:"frequent",readRate:"frequent"},e.DYNAMIC_DRAW],[{whoWrites:"CPU",whoReads:"GPU",writeRate:"once",readRate:"frequent"},e.STATIC_DRAW],[{whoWrites:"CPU",whoReads:"GPU",writeRate:"once",readRate:"rare"},e.STREAM_DRAW],[{whoWrites:"GPU",whoReads:"CPU",writeRate:"frequent",readRate:"frequent"},e.DYNAMIC_READ],[{whoWrites:"GPU",whoReads:"CPU",writeRate:"once",readRate:"frequent"},e.STATIC_READ],[{whoWrites:"GPU",whoReads:"CPU",writeRate:"once",readRate:"rare"},e.STREAM_READ],[{whoWrites:"GPU",whoReads:"GPU",writeRate:"frequent",readRate:"frequent"},e.DYNAMIC_COPY],[{whoWrites:"GPU",whoReads:"GPU",writeRate:"once",readRate:"frequent"},e.STATIC_COPY],[{whoWrites:"GPU",whoReads:"GPU",writeRate:"once",readRate:"rare"},e.STREAM_COPY]];e:for(const[e,i]of r){for(const[r,i]of Object.entries(e))if(null!=t[r]&&t[r]!=i)continue e;return i}}throw new Error(`'${JSON.stringify(t)}' is invalid buffer optimization hint`)},frameMask(t){switch(t){case"color":return e.COLOR_BUFFER_BIT;case"depth":return e.DEPTH_BUFFER_BIT;case"stencil":return e.STENCIL_BUFFER_BIT;default:throw new Error(`'${t}' is invalid frame mask`)}},uniformType(t){switch(t){case e.FLOAT:return[e.uniform1fv,!1,!1];case e.FLOAT_VEC2:return[e.uniform2fv,!1,!1];case e.FLOAT_VEC3:return[e.uniform3fv,!1,!1];case e.FLOAT_VEC4:return[e.uniform4fv,!1,!1];case e.INT:return[e.uniform1iv,!1,!1];case e.INT_VEC2:return[e.uniform2iv,!1,!1];case e.INT_VEC3:return[e.uniform3iv,!1,!1];case e.INT_VEC4:return[e.uniform4iv,!1,!1];case e.BOOL:return[e.uniform1iv,!1,!1];case e.BOOL_VEC2:return[e.uniform2iv,!1,!1];case e.BOOL_VEC3:return[e.uniform3iv,!1,!1];case e.BOOL_VEC4:return[e.uniform4iv,!1,!1];case e.SAMPLER_2D:case e.SAMPLER_CUBE:case e.SAMPLER_3D:case e.SAMPLER_2D_SHADOW:case e.SAMPLER_2D_ARRAY:case e.SAMPLER_2D_ARRAY_SHADOW:case e.SAMPLER_CUBE_SHADOW:case e.INT_SAMPLER_2D:case e.INT_SAMPLER_3D:case e.INT_SAMPLER_CUBE:case e.INT_SAMPLER_2D_ARRAY:case e.UNSIGNED_INT_SAMPLER_2D:case e.UNSIGNED_INT_SAMPLER_3D:case e.UNSIGNED_INT_SAMPLER_CUBE:case e.UNSIGNED_INT_SAMPLER_2D_ARRAY:return[e.uniform1iv,!1,!0];case e.UNSIGNED_INT:return[e.uniform1uiv,!1,!1];case e.UNSIGNED_INT_VEC2:return[e.uniform2uiv,!1,!1];case e.UNSIGNED_INT_VEC3:return[e.uniform3uiv,!1,!1];case e.UNSIGNED_INT_VEC4:return[e.uniform4uiv,!1,!1];case e.FLOAT_MAT2:return[e.uniformMatrix2fv,!0,!1];case e.FLOAT_MAT3:return[e.uniformMatrix3fv,!0,!1];case e.FLOAT_MAT4:return[e.uniformMatrix4fv,!0,!1]}},attribType(t){switch(t){case e.FLOAT:return[e.vertexAttrib1f,1,1];case e.FLOAT_VEC2:return[e.vertexAttrib2f,2,1];case e.FLOAT_VEC3:return[e.vertexAttrib3f,3,1];case e.FLOAT_VEC4:return[e.vertexAttrib4f,4,1];case e.INT:case e.INT_VEC2:case e.INT_VEC3:case e.INT_VEC4:return[e.vertexAttribI4i,4,1];case e.UNSIGNED_INT:case e.UNSIGNED_INT_VEC2:case e.UNSIGNED_INT_VEC3:case e.UNSIGNED_INT_VEC4:return[e.vertexAttribI4ui,4,1];case e.FLOAT_MAT2:return[e.vertexAttrib2f,2,2];case e.FLOAT_MAT3:return[e.vertexAttrib3f,3,3];case e.FLOAT_MAT4:return[e.vertexAttrib4f,4,4]}},primitive(t){switch(t){case"points":return e.POINTS;case"line-strip":return e.LINE_STRIP;case"line-loop":return e.LINE_LOOP;case"lines":return e.LINES;case"triangle-strip":return e.TRIANGLE_STRIP;case"triangle-fan":return e.TRIANGLE_FAN;case"triangles":return e.TRIANGLES;default:throw new Error(`'${t}' is invalid primitive`)}},pixelFormat(t){switch(t){case"rgba8":return[e.RGBA8,e.RGBA,e.UNSIGNED_BYTE];case"rgb8":return[e.RGB8,e.RGB,e.UNSIGNED_BYTE];case"rg8":return[e.RG8,e.RG,e.UNSIGNED_BYTE];case"r8":return[e.R8,e.RED,e.UNSIGNED_BYTE];case"rgba16f":return[e.RGBA16F,e.RGBA,e.FLOAT];case"rgb16f":return[e.RGB16F,e.RGB,e.FLOAT];case"rg16f":return[e.RG16F,e.RG,e.FLOAT];case"r16f":return[e.R16F,e.RED,e.FLOAT];case"rgba32f":return[e.RGBA32F,e.RGBA,e.FLOAT];case"rgb32f":return[e.RGB32F,e.RGB,e.FLOAT];case"rg32f":return[e.RG32F,e.RG,e.FLOAT];case"r32f":return[e.R32F,e.RED,e.FLOAT];case"rgba32i":return[e.RGBA32I,e.RGBA_INTEGER,e.INT];case"rgb32i":return[e.RGB32I,e.RGB_INTEGER,e.INT];case"rg32i":return[e.RG32I,e.RG_INTEGER,e.INT];case"r32i":return[e.R32I,e.RED_INTEGER,e.INT];case"rgba16i":return[e.RGBA16I,e.RGBA_INTEGER,e.SHORT];case"rgb16i":return[e.RGB16I,e.RGB_INTEGER,e.SHORT];case"rg16i":return[e.RG16I,e.RG_INTEGER,e.SHORT];case"r16i":return[e.R16I,e.RED_INTEGER,e.SHORT];case"rgba8i":return[e.RGBA8I,e.RGBA_INTEGER,e.BYTE];case"rgb8i":return[e.RGB8I,e.RGB_INTEGER,e.BYTE];case"rg8i":return[e.RG8I,e.RG_INTEGER,e.BYTE];case"r8i":return[e.R8I,e.RED_INTEGER,e.BYTE];case"rgba32u":return[e.RGBA32UI,e.RGBA_INTEGER,e.UNSIGNED_INT];case"rgb32u":return[e.RGB32UI,e.RGB_INTEGER,e.UNSIGNED_INT];case"rg32u":return[e.RG32UI,e.RG_INTEGER,e.UNSIGNED_INT];case"r32u":return[e.R32UI,e.RED_INTEGER,e.UNSIGNED_INT];case"rgba16u":return[e.RGBA16UI,e.RGBA_INTEGER,e.UNSIGNED_SHORT];case"rgb16u":return[e.RGB16UI,e.RGB_INTEGER,e.UNSIGNED_SHORT];case"rg16u":return[e.RG16UI,e.RG_INTEGER,e.UNSIGNED_SHORT];case"r16u":return[e.R16UI,e.RED_INTEGER,e.UNSIGNED_SHORT];case"rgba8u":return[e.RGBA8UI,e.RGBA_INTEGER,e.UNSIGNED_BYTE];case"rgb8u":return[e.RGB8UI,e.RGB_INTEGER,e.UNSIGNED_BYTE];case"rg8u":return[e.RG8UI,e.RG_INTEGER,e.UNSIGNED_BYTE];case"r8u":return[e.R8UI,e.RED_INTEGER,e.UNSIGNED_BYTE];default:throw new Error(`'${t}' is invalid pixel format`)}},textureDimension(t){switch(t){case"2d":return[e.texStorage2D,e.texImage2D,e.texSubImage2D,2,e.TEXTURE_2D];case"2d[]":return[e.texStorage3D,e.texImage3D,e.texSubImage3D,3,e.TEXTURE_2D_ARRAY];case"3d":return[e.texStorage3D,e.texImage3D,e.texSubImage3D,3,e.TEXTURE_3D];case"cube":return[e.texStorage2D,e.texImage2D,e.texSubImage2D,2,e.TEXTURE_CUBE_MAP];default:throw new Error(`'${t}' is invalid texture dimension`)}},typedArrayOfType(e){switch(e){case"int8":return Int8Array;case"uint8":return Uint8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float":return Float32Array;default:throw new Error(`'${e}' is not supported`)}},typeOfTypedArray(e){switch(e.__proto__){case Int8Array.prototype:return"int8";case Uint8Array.prototype:case Uint8ClampedArray.prototype:return"uint8";case Int16Array.prototype:return"int16";case Uint16Array.prototype:return"uint16";case Int32Array.prototype:return"int32";case Uint32Array.prototype:return"uint32";case Float32Array.prototype:return"float";default:throw new Error(`'${e.constructor.name}' is not supported`)}},filter(t){switch(t){case"linear":return e.LINEAR;case"nearest":return e.NEAREST}throw new Error(`'${t}' is invalid filtering method`)},wrap(t){switch(t){case"repeat":return e.REPEAT;case"clamp":return e.CLAMP_TO_EDGE;case"mirror":return e.MIRRORED_REPEAT;default:throw new Error(`'${t}' is invalid wrapping method`)}},mutable(e){switch(e){case"dynamic":return!0;case"static":return!1}throw new Error(`'${value}' is invalid mutability`)}}})();export class Matrix2D{constructor(e=1,t=0,r=0,i=1,s=0,n=0){this.v=[e,r,0,t,i,0,s,n,1]}static identity(){return new Matrix2D}static multiply(...e){const t=e[0]??new Matrix2D;for(const r of e.slice(1)){const e=t.v,i=r.v;[e[0],e[1],e[3],e[4],e[6],e[7]]=[e[0]*i[0]+e[3]*i[1],e[1]*i[0]+e[4]*i[1],e[0]*i[3]+e[3]*i[4],e[1]*i[3]+e[4]*i[4],e[0]*i[6]+e[3]*i[7]+e[6],e[1]*i[6]+e[4]*i[7]+e[7]]}return t}translate(e=0,t=0){const r=this.v;return r[6]+=e,r[7]+=t,this}rotate(e=0,t=0,r=0){const i=this.v,s=e/180*Math.PI,n=Math.cos(s),a=Math.sin(s);return[i[0],i[1],i[3],i[4],i[6],i[7]]=[n*i[0]+-a*i[1],a*i[0]+n*i[1],n*i[3]+-a*i[4],a*i[3]+n*i[4],n*i[6]+-a*i[7]+(-n*t+a*r+t),a*i[6]+n*i[7]+(-a*t-n*r+r)],this}scale(e=1,t=1,r=0,i=0){this.v;return this.v=Matrix2D.multiply(this,new Matrix2D(e,0,0,t,0,0)).v,this}skew(e=0,t=0){const r=this.v,i=e/180*Math.PI,s=t/180*Math.PI;return r[3]=Math.tan(i),r[1]=Math.tan(s),this}copyTo(e){const t=e.v,r=this.v;return[t[0],t[1],t[3],t[4],t[6],t[7]]=[t[0]*r[0]+t[3]*r[1],t[1]*r[0]+t[4]*r[1],t[0]*r[3]+t[3]*r[4],t[1]*r[3]+t[4]*r[4],t[0]*r[6]+t[3]*r[7]+t[6],t[1]*r[6]+t[4]*r[7]+t[7]],this}get array(){return this.v}[Symbol.iterator](){let e=0;const t=this.v;return{next:()=>e<9?{value:t[e++],done:!1}:{done:!0}}}}class GFXTexture{constructor(e,t,r,i,s,n){this.gfx=e;const a=GFXMappings.textureDimension(t??"2d"),o=GFXMappings.pixelFormat(i??"rgba8"),h=this.gfx.gl;if(this.autoMipmap=s?.autoMipmap??!1,this.mutable=GFXMappings.mutable(r??"dynamic"),this.mipmapStorage=s?.mipmapStorage,this.mipmapStorage&&this.mutable)throw Error("'mipmapStorage' paramater is irrelevant for dynamic textures");this.texture=h.createTexture(),this.texStorage=a[0],this.texImage=a[1],this.texSubImage=a[2],this.dimension=a[3],this.bind=a[4],this.internalFormat=o[0],this.format=o[1],this.type=o[2],this.bind,h.TEXTURE_CUBE_MAP,this.maxAnisotropy=1,this.maxMipmap=1e3,this.wrapS=h.REPEAT,this.wrapT=h.REPEAT,this.wrapR=h.REPEAT,this.minFilter=h.NEAREST_MIPMAP_LINEAR,this.magFilter=h.LINEAR,this.mipmapOutdated=!1,n&&this.sampling(n)}sampling(e){const t=this.gfx,r=t.gl,i=e??{};r.bindTexture(this.bind,this.texture),this.gfx.textureBinds.set(this.bind,this.texture);const s=this.maxAnisotropy;let n;"number"==typeof i.anisotropy?n=i.anisotropy:1==i.anisotropy?n=t.maxAnisotropy:0==i.anisotropy&&(n=0),null!=n&&s!=n&&(r.texParameterf(this.bind,t.anisotropy.TEXTURE_MAX_ANISOTROPY_EXT,n),this.maxAnisotropy=n);const a=this.maxMipmap;let o;"number"==typeof i.mipmap?o=i.mipmap:1==i.mipmap?o=1e3:0==i.mipmap&&(o=0),null!=o&&a!=o&&(r.texParameterf(this.bind,r.TEXTURE_MAX_LEVEL,o),this.maxMipmap=o);const h=this.wrapS,u=i.wrapX??i.wrap;let c;u&&(c=GFXMappings.wrap(u)),null!=c&&h!=c&&(r.texParameterf(this.bind,r.TEXTURE_WRAP_S,c),this.wrapS=c);const l=this.wrapT,f=i.wrapY??i.wrap;let g;f&&(g=GFXMappings.wrap(f)),null!=g&&l!=g&&(r.texParameterf(this.bind,r.TEXTURE_WRAP_T,g),this.wrapT=g);const d=this.wrapR,p=i.wrapZ??i.wrap;let E;p&&(E=GFXMappings.wrap(p)),null!=E&&d!=E&&(r.texParameterf(this.bind,r.TEXTURE_WRAP_R,E),this.wrapR=E);const m=this.magFilter,T=i.filterFar??i.filter;let R;T&&(R=GFXMappings.filter(T)),null!=R&&m!=R&&(r.texParameterf(this.bind,r.TEXTURE_MAG_FILTER,R),this.magFilter=R);const x=i.filterNear??i.filter,_=x?GFXMappings.filter(x):this.minFilter,b=this.maxMipmap>0?_==r.LINEAR?r.LINEAR_MIPMAP_LINEAR:r.NEAREST_MIPMAP_LINEAR:_;return a===this.maxMipmap&&this.minFilter===_||(r.texParameterf(this.bind,r.TEXTURE_MIN_FILTER,b),this.minFilter=_),this}write(e,t){const r=this.gfx,i=r.gl;let s;if(null!=t)s=[...t];else if(2==this.dimension&&e instanceof HTMLImageElement||e instanceof HTMLCanvasElement||e instanceof ImageBitmap)s=[e.width,e.height];else{if(!this.size)throw new Error("You can't just 'write' to texture without letting it know the size. Specify any size (e.g, [1, 1]) or pass 'data' with size obtainable (e.g. ImageBitmap)");s=[...this.size]}if(s.some((e=>e>r.maxTextureSize)))throw new Error("Texture is too big. Your device doesn't support such a big texture");const n=this.size??[],a=!(n.length==s.length&&n.every(((e,t)=>e===s[t])));if(!this.mutable&&this.size&&a)throw new Error("Can't resize immutable texture");if(i.bindTexture(this.bind,this.texture),this.gfx.textureBinds.set(this.bind,this.texture),a){if(this.mutable)this.texImage.call(i,this.bind,0,this.internalFormat,...s,0,this.format,this.type,e),this.mipmapOutdated=!0;else{let e=Math.floor(Math.log2(Math.max(...s)))+1;null!=this.mipmapStorage&&this.mipmapStorage<e&&(e=this.mipmapStorage),this.texStorage.call(i,this.bind,e,this.internalFormat,...s)}this.size=s}if(!a||!this.mutable)if(null!=e)this.texSubImage.call(i,this.bind,0,0,0,...t??s,this.format,this.type,e),this.mipmapOutdated=!0;else if(!a)throw new Error("Passed 'null' as data to fill allocated texture");return this}subwrite(e,t,r=[0,0]){const i=this.gfx,s=i.gl;if(null==e)throw new Error("Passed 'null' as data to fill allocated texture");let n;if(null!=t)n=[...t];else if(2==this.dimension&&e instanceof HTMLImageElement||e instanceof HTMLCanvasElement||e instanceof ImageBitmap)n=[e.width,e.height];else{if(!this.size)throw new Error("You can't 'subwrite' to unallocated texture");n=[...this.size]}return s.bindTexture(this.bind,this.texture),i.textureBinds.set(this.bind,this.texture),this.texSubImage.call(s,this.bind,0,...r,...n,this.format,this.type,e),this}genMipmap(){const e=this.gfx.gl;e.bindTexture(this.bind,this.texture),this.gfx.textureBinds.set(this.bind,this.texture),e.generateMipmap(this.bind),this.mipmapOutdated=!1}get width(){return this.size?.[0]}get height(){return this.size?.[1]}get depth(){return this.size?.[2]}get ratio(){return this.size?.[0]/this.size?.[1]}delete(){this.gfx.gl.deleteTexture(this.texture),this.texture=null,this.delete=()=>{throw new Error("Can't delete twice")}}get exists(){return null!=this.texture}}class GFXVirtualScreen{constructor(e,t,r){this.gfx=e;const i=e.gl;let s;this.framebuffer=i.createFramebuffer(),this._deleters=[()=>i.deleteFramebuffer(this.framebuffer)],this._resizers=[],i.bindFramebuffer(i.FRAMEBUFFER,this.framebuffer),e.currentScreen=this;const n=[];let a=0;const o=t instanceof GFXTexture?[t]:t??[];this.textures=o;for(const t of o){let r=i.COLOR_ATTACHMENT0+a++;null!=t?(s=s??t.size,i.bindTexture(i.TEXTURE_2D,t.texture),e.textureBinds.set(i.TEXTURE_2D,t.texture),i.framebufferTexture2D(i.FRAMEBUFFER,r,i.TEXTURE_2D,t.texture,0),this._resizers.push(((e,r)=>{e==t.width&&r==t.height||t.write(null,[e,r])})),n.push(r)):n.push(i.NONE)}if(0==o.length)throw new Error("At least 1 texture needed");let h;const u=r??[],c=u.includes("stencil");if(u.includes("depth")?h=c?[i.DEPTH_STENCIL,i.DEPTH_STENCIL_ATTACHMENT]:[i.DEPTH_COMPONENT16,i.DEPTH_ATTACHMENT]:c&&(h=[i.STENCIL_INDEX8,i.STENCIL_ATTACHMENT]),null!=h){const e=i.createRenderbuffer();this._deleters.push((()=>i.deleteRenderbuffer(e))),i.bindRenderbuffer(i.RENDERBUFFER,e),s&&i.renderbufferStorage(i.RENDERBUFFER,h[0],...s),i.framebufferRenderbuffer(i.FRAMEBUFFER,h[1],i.RENDERBUFFER,e),this._resizers.push(((t,r)=>{i.bindRenderbuffer(i.RENDERBUFFER,e),i.renderbufferStorage(i.RENDERBUFFER,h[0],t,r)}))}i.drawBuffers(n)}get complete(){const e=this.gfx.gl;e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer),this.currentScreen=this;return e.checkFramebufferStatus(e.FRAMEBUFFER)==e.FRAMEBUFFER_COMPLETE}resize(e,t){const r=this.gfx,i=r.gl;return i.bindFramebuffer(i.FRAMEBUFFER,this.framebuffer),r.currentScreen=this,this._resizers.forEach((r=>r(e,t))),this}delete(){this._deleters.forEach((e=>e())),this._deleters=null,this.delete=()=>{throw new Error("Can't delete twice")}}get exists(){return null!=this._deleters}}class GFXShader{constructor(e,t,r){this.gfx=e;const i=e.gl,s=i.createShader(GFXMappings.shaderType(t)),n=r.match(/^\s*#version.*\n*/)?.[0];i.shaderSource(s,[(n??"#version 300 es").trim(),"precision highp float;",r.slice(n?.length??0)].join("\n")),i.compileShader(s);const a=i.getShaderInfoLog(s);if(a.length>0)throw this.delete(),new Error(`Shader compiling failed:\n${a}`);this.shader=s}delete(){this.gfx.gl.deleteShader(this.shader),this.shader=null,this.delete=()=>{throw new Error("Can't delete twice")}}get exists(){return null!=this.shader}}class GFXBufferBase{constructor(e,t,r=null){this.gfx=e,this.bind=t,this.newUsage=GFXMappings.bufferUsage(r??"dynamic-draw"),this.byteLength=0,this.buffer=e.gl.createBuffer()}hint(e){return this.newUsage=GFXMappings.bufferUsage(e),this}write(e,t){const r=this.gfx.gl;if(e instanceof Array){e=new(GFXMappings.typedArrayOfType(t??"float"))(e)}return r.bindBuffer(this.bind,this.buffer),this.usage==this.newUsage&&this.byteLength==e.byteLength?r.bufferSubData(this.bind,0,e):(this.usage=this.newUsage,r.bufferData(this.bind,e,this.usage),this.byteLength=e.byteLength),this}alloc(e){const t=this.gfx.gl;return t.bindBuffer(this.bind,this.buffer),this.usage==this.newUsage&&this.byteLength==e||(this.usage=this.newUsage,t.bufferData(this.bind,e,this.usage),this.byteLength=e),this}subwrite(e,t,r){const i=this.gfx.gl;if(e instanceof Array){e=new(GFXMappings.typedArrayOfType(r??"float"))(e)}return i.bindBuffer(this.bind,this.buffer),i.bufferSubData(this.bind,t??0,e),this}read(e=0){const t=this.gfx.gl;t.bindBuffer(this.bind,this.buffer);const r=new ArrayBuffer(this.byteLength-e);return t.getBufferSubData(this.bind,e,new DataView(r)),r}readTo(e,t,r){const i=this.gfx.gl;return i.bindBuffer(this.bind,this.buffer),i.getBufferSubData(this.bind,t,e,0,Math.floor(r/(e.BYTES_PER_ELEMENT??1))),this}copyTo(e,t,r,i){const s=this.gfx.gl;return s.bindBuffer(s.COPY_READ_BUFFER,this.buffer),s.bindBuffer(s.COPY_WRITE_BUFFER,e.buffer),s.copyBufferSubData(s.COPY_READ_BUFFER,s.COPY_WRITE_BUFFER,t??0,r??0,i??this.byteLength),this}delete(){this.gfx.gl.deleteBuffer(this.buffer),this.buffer=null,this.delete=()=>{throw new Error("Can't delete twice")}}get exists(){return null!=this.buffer}}class GFXBuffer extends GFXBufferBase{constructor(e,t=null){super(e,e.gl.ARRAY_BUFFER,t)}}class GFXIndexBuffer extends GFXBufferBase{constructor(e,t=null){super(e,e.gl.ELEMENT_ARRAY_BUFFER,t)}}class GFXShaderAttribute{constructor(e,t,r){this.gfx=e,this.location=t;const i=GFXMappings.attribType(r);this.func=i[0],this.padTo=i[1],this.maxCallCount=i[2]}setBuffer(e,t,r,i=!1){const s=this.gfx.gl,n=GFXMappings.numberType(t);return this.gfx.arrayedAttrs.has(this.location)||(this.gfx.arrayedAttrs.add(this.location),s.enableVertexAttribArray(this.location)),s.bindBuffer(s.ARRAY_BUFFER,e.buffer),s.vertexAttribPointer(this.location,r,n,i,0,0),this.gfx.attributes}setSingle(...e){const t=this.gfx.gl;this.gfx.arrayedAttrs.has(this.location)&&(this.gfx.arrayedAttrs.delete(this.location),t.disableVertexAttribArray(this.location));const r=Math.min(e.length,this.maxCallCount*this.padTo);for(let i=0;i<r;i+=this.padTo)this.func.call(t,this.location+i/this.padTo,...e.slice(i,i+this.padTo),0,0,0,0)}}class GFXShaderUniform{constructor(e,t,r){this.program=e,this.location=t,this.type=r;const i=GFXMappings.uniformType(r);this.func=i[0],this.isMatrix=i[1],this.isSampler=i[2]}#e(e,t){const r=this.program,i=r.gfx,s=i.gl;let n=[s,this.location];this.isMatrix&&n.push(e);let a=[];for(const e of t)e?.[Symbol.iterator]?a.push(...e):a.push(e);return a=a.map((e=>{if(e instanceof GFXTexture){const t=i.textureSlotCounter;return i.setTextureSlot(t,e),i.textureSlotCounter=(i.textureSlotCounter+1)%i.textureSlotsCount,t}return e})),this.isSampler&&r.usedTextureSlots.set(this,a),n.push(a),i.currentProgram!=this.program&&(s.useProgram(this.program.program),i.currentProgram=this.program),this.func.call(...n),this.program.uniforms}set(...e){return this.#e(!1,e)}setTransposed(...e){return this.#e(!0,e)}}class GFXShaderBlock{constructor(e,t,r,i){this.program=e,this.index=t,this.bindingPoint=r,this.byteLength=i}set(e){const t=this.program.gfx,r=t.gl;if(e instanceof GFXBuffer){const i=e;e=t.blockSlotCounter,r.bindBufferBase(r.UNIFORM_BUFFER,e,i.buffer),t.blockSlotCounter=(t.blockSlotCounter+1)%t.blockSlotsCount}return this.bindingPoint!=e&&(r.uniformBlockBinding(this.program.program,this.index,e),this.bindingPoint=e),this.program.blocks}}class GFXShaderProgram{#t;#r;constructor(e,t,r,i=!1,s=!1){this.gfx=e;const n=e.gl;this.program=n.createProgram(),n.attachShader(this.program,t.shader),n.attachShader(this.program,r.shader),n.linkProgram(this.program),this.#t=t,this.#r=r,this.ownsVertexShader=i,this.ownsFragmentShader=s,this.attributes={};let a=n.getProgramParameter(this.program,n.ACTIVE_ATTRIBUTES);for(let e=0;e<a;++e){const t=this.gfx.gl.getActiveAttrib(this.program,e),r=n.getAttribLocation(this.program,t.name);if(-1==r)continue;const i=new GFXShaderAttribute(this.gfx,r,t.type);this.attributes[t.name]=i,this.attributes[i.location]=i}this.attributes=new Proxy(this.attributes,{get(e,t){if(null!=e[t])return e[t];const r=t.charCodeAt(0);if(r>47&&r<58)return new GFXShaderAttribute(this,Number(t));throw new Error(`Attribute '${t}' doesn't exist in the shader program. There's a chance that it was optimized out, check for sure`)}}),this.uniforms={};let o=n.getProgramParameter(this.program,n.ACTIVE_UNIFORMS);for(let e=0;e<o;++e){const t=n.getActiveUniform(this.program,e),r=n.getUniformLocation(this.program,t.name),i=new GFXShaderUniform(this,r,t.type);this.uniforms[t.name]=i;const s=t.name.match(/([^\[\].]+)/g);"0"==s[s.length-1][0]&&s.pop();let a=this.uniforms;for(let e=0;e<s.length;++e){const t=s[e];if(a[t]){if(a[t]instanceof GFXShaderUniform)break}else a[t]=e==s.length-1?i:{};a=a[t]}}this.uniforms=new Proxy(this.uniforms,{get(e,t){if(null==e[t])throw new Error(`Uniform '${t}' doesn't exist in the shader program. There's a chance that it was optimized out, check for sure`);return e[t]}}),this.blocks={};let h=n.getProgramParameter(this.program,n.ACTIVE_UNIFORM_BLOCKS);for(let e=0;e<h;++e){const t=n.getActiveUniformBlockName(this.program,e),r=n.getUniformBlockIndex(this.program,t),i=n.getActiveUniformBlockParameter(this.program,r,n.UNIFORM_BLOCK_BINDING),s=n.getActiveUniformBlockParameter(this.program,r,n.UNIFORM_BLOCK_DATA_SIZE),a=new GFXShaderBlock(this,r,i,s);this.blocks[t]=a,this.blocks[r]=a}this.blocks=new Proxy(this.blocks,{get(e,t){if(null==e[t])throw new Error(`Block (Uniform block) '${t}' doesn't exist in the shader program. There's a chance that it was optimized out, check for sure`);return e[t]}}),this.usedTextureSlots=new Map}delete(){return this.gfx.gl.deleteProgram(this.program),this.program=null,this.ownsVertexShader&&this.#t.exists&&this.#t.delete(),this.ownsFragmentShader&&this.#r.exists&&this.#r.delete(),this.delete=()=>{throw new Error("Can't delete twice")},this}get exists(){return null!=this.program}get fragmentShader(){if(this.ownsFragmentShader)return this.#r}get vertexShader(){if(this.ownsVertexShader)return this.#t}}export class GFX{constructor(e,t){null==e&&(e=document.createElement("canvas")),"string"==typeof e&&(e=document.querySelector(e)),this.canvas=e;const r=e.getContext("webgl2",{alpha:!1,desynchronized:!0,preserveDrawingBuffer:!0,...t});if(null==r)throw new Error("WebGL2 not supported");this.gl=r,r.enable(r.DEPTH_TEST),r.depthFunc(r.LEQUAL),r.enable(r.BLEND),r.blendFunc(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA),this.ext={},this.anisotropy=r.getExtension("EXT_texture_filter_anisotropic"),this.maxAnisotropy=r.getParameter(this.anisotropy.MAX_TEXTURE_MAX_ANISOTROPY_EXT),this.maxMipmap=Math.floor(Math.log2(r.getParameter(r.MAX_TEXTURE_SIZE)))+1,this.attributes=new Proxy({},{get:(e,t)=>{const r=t.charCodeAt(0);if(r>47&&r<58)return new GFXShaderAttribute(this,Number(t));if(this.programForDrawing)return this.programForDrawing.attributes[t];throw new Error("Referring to attributes by their names via gfx.attributes requires program to be selected")}}),this.arrayedAttrs=new Set,this.blockSlotsCount=r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS),this.blockSlotCounter=0,this.textureSlotsCount=r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS),this.textureSlotCounter=0,this.textureBinds=new Map,this.maxTextureSize=r.getParameter(r.MAX_TEXTURE_SIZE),this.screenForDrawing=null,this.scissorsForDrawing=null,this.textureSlots=new Map}setDrawArea(e,t,r,i){return this.scissorsForDrawing=[e,t,r,i],this}resetDrawArea(){return this.scissorsForDrawing=null,this}setBlockSlot(e,t){const r=this.gl;return r.bindBufferBase(r.UNIFORM_BUFFER,e,t.buffer),this}setTextureSlot(e,t){const r=this.gl;return this.textureSlots.set(e,t),this.activeTextureBind==t.bind&&this.textureBinds.get(this.activeTextureBind)!=this.activeTexture&&(r.bindTexture(this.activeTextureBind,this.activeTexture),this.textureBinds.set(this.activeTextureBind,this.activeTexture)),r.activeTexture(r.TEXTURE0+e),r.bindTexture(t.bind,t.texture),this.textureBinds.set(t.bind,t.texture),this.activeTextureBind=t.bind,this.activeTexture=t.texture,this}compileShader(e,t){const r=e.match(/^\s*#version.*\n*/)?.[0]??"",i=e.substring(r.length);return r+[...(t instanceof Array?t.map((e=>[e])):Object.entries(t??{})).map((e=>null==e[1]?`#define ${e[0]}`:`#define ${e[0]} ${e[1]}`)),i].join("\n")}consolidateShaders(...e){function t(e,t){const r=new Set,i=[e];!function e(s){const n=Object.entries(s);for(let a=0;a<n.length;++a){const o=n[a][1];if("object"==typeof o&null!==o){if(r.has(o))continue;if(r.add(o),i!=s&&(o._parent=s,o._indexInParent=n[a][0]),"type"==Object.keys(o)[0]){const e={node:o};t(e),n[a][1]=e.node}e(o)}}}(i)}let r=[];const i=new Set;for(let s=0;s<e.length;++s){const n=(()=>{const t=new Map;return e[s].split(/\r?\n/).map(((e,r)=>{const n=e.trim();if(/^#version/.test(n))return i.add(n.split(/\s+/).slice(1).join(" ")),null;if(/^#define\s+(\w+)/.test(n)){const e=n.split(" ")[1];t.set(e,`_frag${s+1}_${e}`)}let a=e;for(const[e,r]of t)a=a.replace(new RegExp(`\\b${e}\\b`,"g"),r);return a})).filter((e=>null!=e)).join("\n")})(),a=frog.parser.parse(n),o=a.scopes.find((e=>"global"==e.name)),h=Object.entries(o.types).concat(Object.entries(o.bindings)),u=new Map;for(const[e,t]of h)if(u.set(e,`_frag${s+1}_${e}`),t.references)for(const e of Object.values(t.references))e.identifier=u.get(e.identifier);const c=new Map;for(const[e,t]of Object.entries(Object.fromEntries(Object.entries(o.functions).filter((e=>Object.values(e[1]).every((e=>"UNKNOWN TYPE"!=e.returnType))))))){const r=`_frag${s+1}_${e}`;c.set(e,r),Object.values(t)[0].declaration.prototype.header.name.identifier=r}a.program=a.program.filter((e=>{if("declaration_statement"!=e.type)return!0;if(!e.declaration?.specified_type?.qualifiers?.some((e=>"out"==e.token)))return!0;if("keyword"!=e.declaration.specified_type.specifier.specifier.type)throw new Error("Can't consolidate with non-primitive out");return console.log(e.declaration.specified_type.specifier.specifier.token),console.log(e.declaration.declarations.map((e=>e.identifier.identifier))),!1})),t(a,(e=>{if("fully_specified_type"==e.node.type){const t=e.node.qualifiers?.some((e=>"keyword"==e.type&&["lowp","mediump","highp"].includes(e.token)))??!1,r=e.node.specifier.specifier.token;if(t||"void"==r)return;let i=[r];["vec2","vec3","vec4","mat2","mat3","mat4"].includes(r)&&i.push("float"),["ivec2","ivec3","ivec4","uint"].includes(r)&&i.push("int");const s=(()=>{let t,r=e.node;for(;r;){[r,t]=(e=>{for(;;){let t=e;if((e=e._parent)instanceof Array||null==e)return[e,e?.indexOf(t)]}})(r);for(let e=t-1;e>=0;--e){const t=r[e];if("declaration_statement"==t.type&&"precision"==t?.declaration?.type&&i.includes(t.declaration.specifier.specifier.token))return t.declaration.qualifier.token}}})();return e.node.qualifiers||(e.node.qualifiers=[]),void(s&&e.node.qualifiers.push({type:"keyword",token:s,whitespace:" "}))}if("function_call"!=e.node.type);else{const t=e.node.identifier.specifier.identifier,r=c.get(t);r&&(e.node.identifier.specifier.identifier=r)}})),t(a,(e=>{"declaration_statement"==e.node.type&&"precision"==e.node.declaration?.type&&delete e.node._parent[e.node._indexInParent]})),r.push(a)}if(i.size>1||1==i.size&&!i.has("300 es"))throw new Error("Unsupported shader version");let s="#define FRAG_COLOR 123",n=`void main(){${e.map(((e,t)=>`_frag${t+1}_main();`)).join("")}}`;return[s,...r,n].map((e=>frog.generate(e))).join("\n")}createShader(e,t){return new GFXShader(this,e,t)}createProgram(e,t){const r=!(e instanceof GFXShader),i=r?this.createShader("vertex",e):e,s=!(t instanceof GFXShader),n=s?this.createShader("fragment",t):t;return new GFXShaderProgram(this,i,n,r,s)}useProgram(e){return this.programForDrawing=e,this}useIndices(e){return this.currentIndexBuffer=e,this}createScreen(e,t){return new GFXVirtualScreen(this,e,t)}useScreen(e){return this.screenForDrawing=e,this}get size(){return[this.canvas.width,this.canvas.height]}set size(e){this.canvas.width=e[0],this.canvas.height=e[1]}get width(){return this.canvas.width}set width(e){this.canvas.width=e}get height(){return this.canvas.height}set height(e){this.canvas.height=e}get ratio(){const e=this.canvas;return e.width/e.height}get uniforms(){if(null==this.programForDrawing)throw new Error("gfx.uniforms requires program to be selected");return this.programForDrawing.uniforms}get blocks(){if(null==this.programForDrawing)throw new Error("gfx.blocks requires program to be selected");return this.programForDrawing.blocks}#i(){const e=this.gl,t=[],r=this.currentScissors??t,i=this.scissorsForDrawing??t;if((r.length!=i.length||r.some(((e,t)=>e!==i[t])))&&(null!=this.scissorsForDrawing?(null==this.currentScissors&&e.enable(e.SCISSOR_TEST),e.scissor(...i)):null!=this.currentScissors&&e.disable(e.SCISSOR_TEST),this.currentScissors=this.scissorsForDrawing),this.currentScreen!=this.screenForDrawing){if(this.screenForDrawing&&!this.screenForDrawing.complete)throw new Error("Screen is not valid");e.bindFramebuffer(e.FRAMEBUFFER,this.screenForDrawing?.framebuffer),this.currentScreen=this.screenForDrawing}if(this.screenForDrawing)for(const e of this.screenForDrawing.textures)e.mipmapOutdated=!0}#s(){this.#i();const e=this.gl;if(!this.programForDrawing)throw new Error("Can't draw without program");for(const[e,t]of this.programForDrawing.usedTextureSlots)for(const e of t){const t=this.textureSlots.get(e);t&&t.autoMipmap&&t?.mipmapOutdated&&t.genMipmap()}this.currentProgram!=this.programForDrawing&&(e.useProgram(this.programForDrawing.program),this.currentProgram=this.programForDrawing),this.textureBinds.get(this.activeTextureBind)!=this.activeTexture&&(e.bindTexture(this.activeTextureBind,this.activeTexture),this.textureBinds.set(this.activeTextureBind,this.activeTexture))}drawVertices(e,t,r=0,i=1){return this.#s(),this.gl.drawArraysInstanced(GFXMappings.primitive(e),r,t,i),this}drawIndices(e,t,r,i=0,s=1){const n=this.gl;if(!this.currentIndexBuffer)throw new Error("No index buffer selected. Use gfx.useIndices");return n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.currentIndexBuffer.buffer),this.#s(),n.drawElementsInstanced(GFXMappings.primitive(e),r,GFXMappings.numberType(t),i,s),this}setClearDepth(e){return this.gl.clearDepth(e),this}setClearStencil(e){return this.gl.clearStencil(e),this}setClearColor(e){return this.colorForClearing=[e[0],e[1],e[2],e[3]??1],this.gl.clearColor(...this.colorForClearing),this}clear(...e){this.#i();const t=this.gl,r=e.length?e.reduce(((e,t)=>e|GFXMappings.frameMask(t)),0):t.COLOR_BUFFER_BIT;return t.clear(r),this}setTexture(e,t){const r=this.gl;return r.activeTexture(r.TEXTURE0+e),r.bindTexture(r.TEXTURE_2D,t.texture),this.activeTextureBind=t.bind,this.activeTexture=t.texture,this}viewport(e,t,r,i){return this.gl.viewport(e??0,t??0,r??this.canvas.width,i??this.canvas.height),this}finish(){return this.gl.finish(),this}createBuffer(e){return new GFXBuffer(this,e)}createIndexBuffer(e){return new GFXIndexBuffer(this,e)}createTexture(e,t,r,i,s){return new GFXTexture(this,e,t,r,i,s)}delete(){this.gl.deleteFramebuffer(this.helperFramebuffer),this.deleted=!0,this.delete=()=>{throw new Error("Can't delete twice")}}get exists(){return!this.deleted}}export const sampleShaders={vertex:{fullscreenNoBuffer:"\n            out vec2 vUV;\n            void main() {\n                int bits = gl_VertexID % 3 + gl_VertexID / 3;\n                vec2 v = vec2(bits >> 1 & 1, bits & 1);\n                vUV = v;\n                gl_Position = vec4(v * 2. - 1., 0, 1);\n            }",yFlippedFullscreenNoBuffer:"\n            out vec2 vUV;\n            void main() {\n                int bits = gl_VertexID % 3 + gl_VertexID / 3;\n                vec2 v = vec2(bits >> 1 & 1, bits & 1);\n                vUV = v;\n                gl_Position = vec4((v * 2. - 1.) * vec2(1, -1), 0, 1);\n            }"},fragment:{fancyWhiteNoise:"\n            uniform float uTime;\n            in vec2 vUV;\n            out vec4 fragColor;\n            void main() {\n                fragColor = vec4(vec3(fract(sin(dot(vUV, vec2(12.9898, 78.233))) * 43758.5453 + uTime)), 1.0);\n            }",hsvPalette:"\n            in vec2 vUV;\n            out vec4 fragColor;\n            vec3 hsv2rgb(vec3 hsv) {\n                vec3 rgb;\n                float c = hsv.y * hsv.z;\n                float x = c * (1.0 - abs(mod((hsv.x / 60.0), 2.0) - 1.0));\n                float m = hsv.z - c;\n                \n                if (hsv.x >= 0.0 && hsv.x < 60.0)\n                    rgb = vec3(c, x, 0.0);\n                else if (hsv.x >= 60.0 && hsv.x < 120.0)\n                    rgb = vec3(x, c, 0.0);\n                else if (hsv.x >= 120.0 && hsv.x < 180.0)\n                    rgb = vec3(0.0, c, x);\n                else if (hsv.x >= 180.0 && hsv.x < 240.0)\n                    rgb = vec3(0.0, x, c);\n                else if (hsv.x >= 240.0 && hsv.x < 300.0)\n                    rgb = vec3(x, 0.0, c);\n                else if (hsv.x >= 300.0 && hsv.x <= 360.0)\n                    rgb = vec3(c, 0.0, x);\n                else\n                    rgb = vec3(0.0);\n                return rgb + m;\n            }\n            void main() {\n                fragColor = vec4(hsv2rgb(vec3(vUV.x * 360.0, vUV.y, 1.0)), 1);\n            }",passThrough:"\n            uniform sampler2D uTextureID;\n            in vec2 vUV;\n            out vec4 fragColor;\n            void main() {\n                fragColor = texture(uTextureID, vUV);\n            }\n        "}};