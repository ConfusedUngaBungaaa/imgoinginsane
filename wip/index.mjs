import{$1,$fmod,$hsv2rgb,$time,$shuffle,$sleep}from"/util.mjs";export function $choice(e){return e[~~(Math.random()*e.length)]}const canvas=$1("canvas"),gl=canvas.getContext("webgl2"),blurRadius=1,qualityScale=1/16,speed=.25;let program2,program3,program4,program5,texture2,texture3,framebuffer1,framebuffer2;function createProgram2(){const e=gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(e,"#version 300 es\n        precision highp float;\n        precision highp sampler2D;\n        const vec2 cUVs[] = vec2[](vec2(1, 1), vec2(-1, 1), vec2(-1, -1), vec2(-1, -1), vec2(1, -1), vec2(1, 1));\n        out vec2 vUV;\n        void main(void) {\n            gl_Position = vec4(cUVs[gl_VertexID], 0.0, 1.0);\n            vUV = cUVs[gl_VertexID] / 2.0 + 0.5;\n        }\n    "),gl.compileShader(e),gl.getShaderParameter(e,gl.COMPILE_STATUS)||console.log("An error occurred compiling the shaders: "+gl.getShaderInfoLog(e));const r=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(r,`#version 300 es\n        precision highp float;\n\n        uniform float uTime;\n        in vec2 vUV;\n        out vec4 glFragColor;\n        \n        vec3 hsv2rgb(vec3 hsv) {\n            vec3 rgb;\n            float c = hsv.y * hsv.z;\n            float x = c * (1.0 - abs(mod((hsv.x / 60.0), 2.0) - 1.0));\n            float m = hsv.z - c;\n            \n            if (hsv.x >= 0.0 && hsv.x < 60.0) {\n                rgb = vec3(c, x, 0.0);\n            } else if (hsv.x >= 60.0 && hsv.x < 120.0) {\n                rgb = vec3(x, c, 0.0);\n            } else if (hsv.x >= 120.0 && hsv.x < 180.0) {\n                rgb = vec3(0.0, c, x);\n            } else if (hsv.x >= 180.0 && hsv.x < 240.0) {\n                rgb = vec3(0.0, x, c);\n            } else if (hsv.x >= 240.0 && hsv.x < 300.0) {\n                rgb = vec3(x, 0.0, c);\n            } else if (hsv.x >= 300.0 && hsv.x < 360.0) {\n                rgb = vec3(c, 0.0, x);\n            } else {\n                rgb = vec3(0.0);\n            }\n            \n            return rgb + m;\n        }\n\n        float fmod(float x, float y) {\n            return x - y * floor(x / y);\n        }\n        \n        float getRandomFloat(vec2 seed) {\n            return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453 + sin(dot(seed.yx, vec2(93.989, 27.345))) * 23456.789);\n        }\n        \n        void main(void) {\n            vec3 hsv = vec3(0.0);\n            float initial = getRandomFloat(vUV*3.1576) * 360.0;\n            float speed = getRandomFloat(vUV) * float(${speed});\n            hsv.x = fmod(initial + uTime * 360.0 * speed, 360.0);\n            hsv.y = 1.0;\n            hsv.z = 1.0;\n            glFragColor = vec4(hsv2rgb(hsv), 1.0);\n        }\n    `),gl.compileShader(r),gl.getShaderParameter(r,gl.COMPILE_STATUS)||console.log("An error occurred compiling the shaders: "+gl.getShaderInfoLog(r));const n=gl.createProgram();return gl.attachShader(n,e),gl.attachShader(n,r),gl.linkProgram(n),n}function createProgram3(){const e=gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(e,"#version 300 es\n        precision highp float;\n        precision highp sampler2D;\n        const vec2 cUVs[] = vec2[](vec2(1, 1), vec2(-1, 1), vec2(-1, -1), vec2(-1, -1), vec2(1, -1), vec2(1, 1));\n        out vec2 vUV;\n        void main(void) {\n            gl_Position = vec4(cUVs[gl_VertexID], 0.0, 1.0);\n            vUV = cUVs[gl_VertexID] / 2.0 + 0.5;\n        }\n    "),gl.compileShader(e),gl.getShaderParameter(e,gl.COMPILE_STATUS)||console.log("An error occurred compiling the shaders: "+gl.getShaderInfoLog(e));const r=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(r,`#version 300 es\n        precision highp float;\n\n        uniform ivec2 uCanvasSize;\n        uniform sampler2D uTextureID;\n        in vec2 vUV;\n        out vec4 glFragColor;\n\n        void main(void) {\n            ivec2 coord = ivec2(int(vUV.x * float(uCanvasSize.x)), int(vUV.y * float(uCanvasSize.y)));\n            vec3 rgb = vec3(0, 0, 0);\n            float weightSum = 0.0;\n            for (int i = -${blurRadius}; i <= ${blurRadius}; i++) {\n                float weight = exp(-float(i * i) / (2.0 * float(${blurRadius})));\n                weightSum += weight;\n                rgb += texelFetch(uTextureID, ivec2(coord.x + i, coord.y), 0).xyz * weight;\n            }\n            glFragColor = vec4(rgb / weightSum, 1.0);\n        }\n    `),gl.compileShader(r),gl.getShaderParameter(r,gl.COMPILE_STATUS)||console.log("An error occurred compiling the shaders: "+gl.getShaderInfoLog(r));const n=gl.createProgram();return gl.attachShader(n,e),gl.attachShader(n,r),gl.linkProgram(n),n}function createProgram4(){const e=gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(e,"#version 300 es\n        precision highp float;\n        precision highp sampler2D;\n        const vec2 cUVs[] = vec2[](vec2(1, 1), vec2(-1, 1), vec2(-1, -1), vec2(-1, -1), vec2(1, -1), vec2(1, 1));\n        out vec2 vUV;\n        void main(void) {\n            gl_Position = vec4(cUVs[gl_VertexID], 0.0, 1.0);\n            vUV = cUVs[gl_VertexID] / 2.0 + 0.5;\n        }\n    "),gl.compileShader(e),gl.getShaderParameter(e,gl.COMPILE_STATUS)||console.log("An error occurred compiling the shaders: "+gl.getShaderInfoLog(e));const r=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(r,`#version 300 es\n        precision highp float;\n\n        uniform ivec2 uCanvasSize;\n        uniform sampler2D uTextureID;\n        in vec2 vUV;\n        out vec4 glFragColor;\n\n        vec3 rgb2hsv(vec3 rgb) {\n            vec3 hsv;\n            float cMax = max(max(rgb.r, rgb.g), rgb.b);\n            float cMin = min(min(rgb.r, rgb.g), rgb.b);\n            float delta = cMax - cMin;\n            if (delta == 0.0) {\n                hsv.x = 0.0;\n            } else if (cMax == rgb.r) {\n                hsv.x = mod((rgb.g - rgb.b) / delta, 6.0);\n            } else if (cMax == rgb.g) {\n                hsv.x = ((rgb.b - rgb.r) / delta) + 2.0;\n            } else {\n                hsv.x = ((rgb.r - rgb.g) / delta) + 4.0;\n            }\n            hsv.x *= 60.0;\n            if (hsv.x < 0.0) {\n                hsv.x += 360.0;\n            }\n            if (cMax == 0.0) {\n                hsv.y = 0.0;\n            } else {\n                hsv.y = delta / cMax;\n            }\n            hsv.z = cMax;\n            \n            return hsv;\n        }\n\n        vec3 hsv2rgb(vec3 hsv) {\n            vec3 rgb;\n            float c = hsv.y * hsv.z;\n            float x = c * (1.0 - abs(mod((hsv.x / 60.0), 2.0) - 1.0));\n            float m = hsv.z - c;\n            \n            if (hsv.x >= 0.0 && hsv.x < 60.0) {\n                rgb = vec3(c, x, 0.0);\n            } else if (hsv.x >= 60.0 && hsv.x < 120.0) {\n                rgb = vec3(x, c, 0.0);\n            } else if (hsv.x >= 120.0 && hsv.x < 180.0) {\n                rgb = vec3(0.0, c, x);\n            } else if (hsv.x >= 180.0 && hsv.x < 240.0) {\n                rgb = vec3(0.0, x, c);\n            } else if (hsv.x >= 240.0 && hsv.x < 300.0) {\n                rgb = vec3(x, 0.0, c);\n            } else if (hsv.x >= 300.0 && hsv.x < 360.0) {\n                rgb = vec3(c, 0.0, x);\n            } else {\n                rgb = vec3(0.0);\n            }\n            \n            return rgb + m;\n        }\n\n        float fmod(float x, float y) {\n            return x - y * floor(x / y);\n        }\n\n        void main(void) {\n            ivec2 coord = ivec2(int(vUV.x * float(uCanvasSize.x)), int(vUV.y * float(uCanvasSize.y)));\n            vec3 rgb = vec3(0, 0, 0);\n            float weightSum = 0.0;\n            for (int i = -${blurRadius}; i <= ${blurRadius}; i++) {\n                float weight = exp(-float(i * i) / (2.0 * float(${blurRadius})));\n                weightSum += weight;\n                rgb += texelFetch(uTextureID, ivec2(coord.x, coord.y + i), 0).xyz * weight;\n            }\n            rgb /= weightSum;\n            vec3 hsv = rgb2hsv(rgb);\n\n            hsv[1] = 0.7;\n            hsv[2] = 1.0;\n\n            vec3 rgb2 = hsv2rgb(hsv);\n            rgb2.r = pow(rgb2.r, 2.) * 0.4 + 0.12;\n            rgb2.b = rgb2.r;\n            rgb2.g = rgb2.r;\n\n            glFragColor = vec4(rgb2, 1.0);\n        }\n    `),gl.compileShader(r),gl.getShaderParameter(r,gl.COMPILE_STATUS)||console.log("An error occurred compiling the shaders: "+gl.getShaderInfoLog(r));const n=gl.createProgram();return gl.attachShader(n,e),gl.attachShader(n,r),gl.linkProgram(n),n}function createProgram5(){const e=gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(e,"#version 300 es\n        precision highp float;\n        precision highp sampler2D;\n        const vec2 cUVs[] = vec2[](vec2(1, 1), vec2(-1, 1), vec2(-1, -1), vec2(-1, -1), vec2(1, -1), vec2(1, 1));\n        out vec2 vUV;\n        void main(void) {\n            gl_Position = vec4(cUVs[gl_VertexID], 0.0, 1.0);\n            vUV = cUVs[gl_VertexID] / 2.0 + 0.5;\n        }\n    "),gl.compileShader(e),gl.getShaderParameter(e,gl.COMPILE_STATUS)||console.log("An error occurred compiling the shaders: "+gl.getShaderInfoLog(e));const r=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(r,"#version 300 es\n        precision highp float;\n\n        uniform sampler2D uTextureID;\n        in vec2 vUV;\n        out vec4 glFragColor;\n\n        void main(void) {\n            glFragColor = texture(uTextureID, vUV);\n        }\n    "),gl.compileShader(r),gl.getShaderParameter(r,gl.COMPILE_STATUS)||console.log("An error occurred compiling the shaders: "+gl.getShaderInfoLog(r));const n=gl.createProgram();return gl.attachShader(n,e),gl.attachShader(n,r),gl.linkProgram(n),n}function init1(){gl.enable(gl.DEPTH_TEST),program2=createProgram2(),program3=createProgram3(),program4=createProgram4(),program5=createProgram5(),texture2=gl.createTexture(),texture3=gl.createTexture(),framebuffer1=gl.createFramebuffer(),framebuffer2=gl.createFramebuffer()}function init2(){gl.bindTexture(gl.TEXTURE_2D,texture2),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,.0625*canvas.width,.0625*canvas.height,0,gl.RGBA,gl.UNSIGNED_BYTE,null),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST),gl.bindTexture(gl.TEXTURE_2D,texture3),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,canvas.width,canvas.height,0,gl.RGBA,gl.UNSIGNED_BYTE,null),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST),gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer1),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture2,0),gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer2),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture3,0)}const r=1e4*Math.random(),t=()=>performance.now()+r,el1=document.querySelector(".title"),el2=document.querySelector(".subtitle");let pos=[.5,.5],vel=[0,0],pos1=[.5,.5],vel1=[0,0],mousePos=[.5,.5];onmousemove=e=>{mousePos=[e.clientX/document.body.clientWidth,e.clientY/document.body.clientHeight]};let t1=performance.now();function frame(){const e=performance.now(),r=e-t1;vel[0]+=(mousePos[0]-pos[0])*r*.01,vel[1]+=(mousePos[1]-pos[1])*r*.01,vel[0]*=.8,vel[1]*=.8,vel1[0]+=(mousePos[0]-pos1[0])*r*.004,vel1[1]+=(mousePos[1]-pos1[1])*r*.004,vel1[0]*=.86,vel1[1]*=.86;const n=[pos[0],pos[1]],o=[pos1[0],pos1[1]];pos[0]=pos[0]+vel[0]*r*.01,pos[1]=pos[1]+vel[1]*r*.01,pos1[0]=pos1[0]+vel1[0]*r*.01,pos1[1]=pos1[1]+vel1[1]*r*.01,t1=e,el1.style=`transform: translate(${Math.round(.5*(pos[0]-.5)*document.body.clientWidth*10)/10}px, ${Math.round(.5*(pos[1]-.5)*document.body.clientHeight*10)/10}px) rotate(${Math.round(60*(n[0]-pos[0])*1e3)/1e3}deg)`,el2.style=`transform: translate(${Math.round(.5*(pos1[0]-.5)*document.body.clientWidth*10)/10}px, ${Math.round(.5*(pos1[1]-.5)*document.body.clientHeight*10)/10}px) rotate(${Math.round(60*(o[0]-pos1[0])*1e3)/1e3}deg)`;{gl.useProgram(program2);const e=gl.getUniformLocation(program2,"uTime");gl.uniform1f(e,performance.now()/1e3),gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer1),gl.clear(gl.COLOR_BUFFER_BIT),gl.viewport(0,0,~~(.0625*canvas.width),~~(.0625*canvas.height)),gl.drawArraysInstanced(gl.TRIANGLES,0,6,1)}{gl.useProgram(program3);const e=gl.getUniformLocation(program3,"uCanvasSize");gl.uniform2iv(e,[.0625*canvas.width,.0625*canvas.height]),gl.activeTexture(gl.TEXTURE0),gl.bindTexture(gl.TEXTURE_2D,texture2);const r=gl.getUniformLocation(program3,"uTextureID");gl.uniform1i(r,0),gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer2),gl.clear(gl.COLOR_BUFFER_BIT),gl.viewport(0,0,.0625*canvas.width,.0625*canvas.height),gl.drawArraysInstanced(gl.TRIANGLES,0,6,1)}{gl.useProgram(program4);const e=gl.getUniformLocation(program4,"uCanvasSize");gl.uniform2iv(e,[.0625*canvas.width,.0625*canvas.height]),gl.activeTexture(gl.TEXTURE0),gl.bindTexture(gl.TEXTURE_2D,texture3);const r=gl.getUniformLocation(program4,"uTextureID");gl.uniform1i(r,0),gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer1),gl.clear(gl.COLOR_BUFFER_BIT),gl.viewport(0,0,.0625*canvas.width,.0625*canvas.height),gl.drawArraysInstanced(gl.TRIANGLES,0,6,1)}{gl.useProgram(program5),gl.activeTexture(gl.TEXTURE0),gl.bindTexture(gl.TEXTURE_2D,texture2);const e=gl.getUniformLocation(program5,"uTextureID");gl.uniform1i(e,0),gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.clear(gl.COLOR_BUFFER_BIT),gl.viewport(0,0,canvas.width,canvas.height),gl.drawArraysInstanced(gl.TRIANGLES,0,6,1)}gl.finish(),requestAnimationFrame(frame)}init1(),init2(),frame(),(async()=>{for(;;){await $sleep(1);const e=$choice(["Goodness is coming","Work in progess","To be continued","Coming soon"]);for(let r=0;r<10;++r)el2.innerText=Array(e.length).fill().map((e=>$choice("`~!@#$%^&*()_+-={}[]:\";'./>?<,\\|".split("")))).join(""),await $sleep(.02);el2.innerText=e,await $sleep(.2),el2.innerText+=".",await $sleep(.2),el2.innerText+=".",await $sleep(.2),el2.innerText+="."}})(),new ResizeObserver((()=>{0!=innerWidth&&0!=innerHeight&&(canvas.width=innerWidth,canvas.height=innerHeight,init2())})).observe(document.body);